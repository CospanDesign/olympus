#Distributed under the MIT licesnse.
#Copyright (c) 2011 Dave McCoy (dave.mccoy@cospandesign.com)

#Permission is hereby granted, free of charge, to any person obtaining a copy of
#this software and associated documentation files (the "Software"), to deal in 
#the Software without restriction, including without limitation the rights to 
#use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies 
#of the Software, and to permit persons to whom the Software is furnished to do 
#so, subject to the following conditions:
#
#The above copyright notice and this permission notice shall be included in all 
#copies or substantial portions of the Software.
#
#THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR 
#IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, 
#FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE 
#AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER 
#LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, 
#OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE 
#SOFTWARE.

"""Module Factory

Generates verilog modules. The generation of a verilog module may by simply
copying the module or generating the module with a script or a combination
of the two
"""

__author__ = 'dave.mccoy@cospandesign.com (Dave McCoy)'

"""Changes:
  06/11/2012
    -Added Documentation and licsense
    -Moved two functions from sapfile to saputils
      is_module_in_file
      find_module_filename
"""


import os
import glob
import sys
from inspect import isclass
from saperror import ModuleNotFound
from saperror import ModuleFactoryError
import saputils


class SapFile:
  """Generates a module

  Based on the script template the modules may be created with a gen script
  or simply copying a file
  """

  def __init__ (self):
#    print "SAPLIB_BASE: " + os.environ["SAPLIB_BASE"]
#    print "Path: " + str(sys.path)
    self.gen_module = None
    self.gen = None
    self.buf = ""
    self.tags = {}
    self.verilog_file_list = []
    self.verilog_dependency_list = []
    return

  def write_file(self, location = "", filename=""):
    """write_file

    Search through the specified location, if the location doesn't exist then
    create the location.
    then write out the specified file

    Args:
      location: the location where the file is to be written
      filename: the name of the output file to write

    Returns:
      Nothing

    Raises:
      IOError
    """
    home = False
    if location.startswith("~"):
      home = True
      location = location.strip("~//")
    fileout = None
    if (home):
      fileout = open(os.getenv("HOME") + "/" +  location + "/" + filename, "w")
    else:
      fileout = open (location + "/" + filename, "w")
    fileout.write(self.buf)
    fileout.close()
    return

  def apply_tags(self):
    """apply_tags

    Substitutes that tags with the data specific to this project

    Args:
      None

    Return:
      Nothing

    Raises:
      KeyError
    """
    #search through the buf for any tags that match something within
    #our tag map
    try:
      self.buf = self.buf.format(self.tags)
    except KeyError as err:
      if ('$' in err):
        raise KeyError(str(err))
    return

  def set_tags(self, tags={}):
    """set_tags

    set the tags for this module
    
    Args:
      tags: project specific tags

    Return:
      Nothing

    Raises:
      Nothing
    """
    self.tags = tags
    return

  def process_file(self, filename = "", file_dict={}, directory="", debug=False):
    """process_file

    read in a file, modify it (if necessary), then write it to the location
    specified by the directory variable

    Args:
      filename: the name of the file to process
      file_dict: dictionary associated with this file
      directory: output directory

    Return:
      
    Raises:
      ModuleFactoryError
      IOError

    """
    if (len(filename) == 0):
      raise ModuleFactoryError ("No filename specified")

    if (len(directory) == 0):
      raise ModuleFactoryError ("No output directory specified")

    if (filename.endswith(".v")):
      self.verilog_file_list.append(filename)

    if (debug):
      print "in process file"
    #maybe load a tags??

    #using the location value in the file_dict find the file and
    #pull it into a buf

    self.buf = ""
    file_location = ""


    #There are two types of files
    #ones that are copied over from a location
    #ones that are generated by scripts

    #The file is specified by a location and basically needs to be copied over
    if file_dict.has_key("location"):
      file_location = os.getenv("SAPLIB_BASE") + "/" + file_dict["location"]
      if (debug):
        print ("getting file: " + filename + " from location: " + file_location)

      found_file = False
      try:
        filein = open(saputils.resolve_linux_path(file_location + "/" + filename))
        self.buf = filein.read()
        filein.close()
        found_file = True
      except IOError as err:
        pass

      if not found_file:
        if debug:
          print "searching for file...",
        try:
          absfilename = saputils.find_rtl_file_location(filename)
          filein = open(absfilename)
          self.buf = filein.read()
          filein.close()
        except:
          if debug:
            print "Failed to find file"
          raise ModuleFactoryError("File %s not found searched %s and in the HDL dir \n \
                                    (%s)" %  (filename, \
                                      file_location, \
                                      os.getenv("SAPLIB_BASE") + "/hdl/rtl"))

      if debug:
        print "found file!"
        print "file content: " + self.buf

    #File is generated by a script
    elif (not file_dict.has_key("gen_script")):
      raise ModuleFactoryError("File %s does not declare a location or a script! Check the template file" % filename)

    if (debug):
      print "Project name: " + self.tags["PROJECT_NAME"]

    #if the generation flag is set in the dictionary
    if (file_dict.has_key("gen_script")):
      if (debug):
        print "found the generation script"
        print "run generation script: " + file_dict["gen_script"]
      #open up the new gen module
      cl = __import__("gen")
      if debug:
        print "cl: " + str(cl)
      Gen = getattr(cl, "Gen")
      if debug:
        print "Gen: " + str(Gen)
      self.gen_module = __import__(file_dict["gen_script"])
      gen_success_flag = False

      #find the script and dynamically add it
      for name in dir(self.gen_module):
        obj = getattr(self.gen_module, name)
  #      print "object type: " + str(obj)
#XXX: debug section start
        if debug:
          print "name: " + name
        if isclass(obj):
          if debug:
            print "\tobject type: " + str(obj)
            print "\tis class"
          if issubclass(obj, cl.Gen):
            if debug:
              print "\t\tis subclass"
#XXX: debug section end
        if isclass(obj) and issubclass(obj, Gen) and obj is not Gen:
          self.gen = obj()
          if debug:
            print "obj = " + str(self.gen)
          self.buf = self.gen.gen_script(tags = self.tags, buf = self.buf)
          gen_success_flag = True

      if not gen_success_flag:
        raise ModuleFactoryError("Failed to execute the generation script %s" %
                                  file_dict["gen_script"])
    else:
      #no script to execute, just tags
      self.apply_tags()

    if debug:
      print self.buf
    #write the file to the specified directory
    if (len(self.buf) > 0):
      result = self.write_file(directory, filename)

    if (self.has_dependencies(filename)):
      deps = self.get_list_of_dependencies(filename)
      for d in deps:
        result = saputils.find_module_filename(d)
        if (len(result) == 0):
          print "Error: couldn't find dependency filename"
          continue
        f = saputils.find_module_filename(d)
        if (f not in self.verilog_dependency_list and
          f not in self.verilog_file_list):
          if debug:
            print "found dependency: " + f
          self.verilog_dependency_list.append(f)

  def resolve_dependencies(self, filename, debug = True):
    """
    given a filename determine if there are any modules it depends on,
    recursively search for any files found in order to extrapolate all
    dependencies
    """
    result = True
    ldebug = debug
    if debug:
      print "in resolve dependencies"
    local_file_list = []
    if debug:
      print "working on filename: " + filename
    if (self.has_dependencies(filename, debug = ldebug)):
      if debug:
        print "found dependencies!"
      deps = self.get_list_of_dependencies(filename, debug = ldebug)
      for d in deps:
        try:
          dep_filename = saputils.find_module_filename(d, debug = ldebug)
        except ModuleNotFound as ex:
          print "Dependency Warning: %s" % (str(ex))
          print "Module Name: %s" % (d)
          print "This warning may be due to:"
          print "\tIncluding a simulation only module"
          print "\tIncluding a vendor specific module"
          print "\tA module that was not found"
          continue

#        if (len(dep_filename) == 0):
#          if debug:
#            print "Couldn't find dependency filename for module " + d
#          continue
#        else :
        if debug:
          print "found the filename: " + dep_filename
        #check this file out for dependecies, then append that on to the local list
        result = self.resolve_dependencies(dep_filename, debug = ldebug)
        if debug:
          if result == True:
            if debug:
              print "found all sub dependencies for: " + dep_filename
        local_file_list.append(dep_filename)

    #go through the local file list and add anything found to the list of dependencies or verilog files
    for f in local_file_list:
      if (not self.verilog_dependency_list.__contains__(f) and
        not self.verilog_file_list.__contains__(f)):

        if debug:
          print "found dependency: " + f
        self.verilog_dependency_list.append(f)

    return result

  def has_dependencies(self, filename, debug = False):
    """look in a verilog module, and search for anything that requires a depency, return true if found"""

    if debug:
      print "input file: " + filename
    #filename needs to be a verilog file
    if (filename.partition(".")[2] != "v"):
      if debug:
        print "File is not a recognized verilog source"
      return False

    fbuf = ""
    #the name is a verilog file, try and open is
    try:
      filein = open(filename)
      fbuf = filein.read()
      filein.close()
    except IOError as err:
      if debug:
        print "the file is not a full path, searching RTL... ",
      #didn't find with full path, search for it
      try:
        filepath = saputils.find_rtl_file_location(filename)
        filein = open(filepath)
        fbuf = filein.read()
        filein.close()
      except IOError as err_int:
        if debug:
          print "couldn't find file in the RTL directory"
        ModuleFactoryError("Couldn't find file %s in the RTL directory" % filename)


    #we have an open file!
    if debug:
      print "found file!"

    #strip out everything we can't use
    fbuf = saputils.remove_comments(fbuf)

    #modules have lines that start with a '.'
    str_list = fbuf.splitlines()

    for item in str_list:
      item = item.strip()
      if (item.startswith(".")):
        if debug:
          print "found a module!"
        return True
    return False

  def get_list_of_dependencies(self, filename, debug=False):
    deps = []
    if debug:
      print "input file: " + filename
    #filename needs to be a verilog file
    if (filename.partition(".")[2] != "v"):
      if debug:
        print "File is not a recognized verilog source"
      return False

    fbuf = ""
    #the name is a verilog file, try and open is
    try:
      filein = open(filename)
      fbuf = filein.read()
      filein.close()
    except IOError as err:
      #if debug:
      #  print "the file is not a full path... searching RTL"
      #didn't find with full path, search for it
      try:
        filepath = saputils.find_rtl_file_location(filename)
        filein = open(filepath)
        fbuf = filein.read()
        filein.close()
      except IOError as err_int:
        #if debug:
        #  print "couldn't find file in the RTL directory"
        return False


    #we have an open file!
    if debug:
      print "found file!"

    #strip out everything we can't use
    fbuf = saputils.remove_comments(fbuf)

    include_fbuf = fbuf
    #search for `include
    while (not len(include_fbuf.partition("`include")[2]) == 0):
      ifile_name = include_fbuf.partition("`include")[2]
      ifile_name = ifile_name.splitlines()[0]
      ifile_name = ifile_name.strip()
      ifile_name = ifile_name.strip("\"")
      if debug:
        print "found an include " + ifile_name + " ",
      if (not self.verilog_dependency_list.__contains__(ifile_name) and
        not self.verilog_file_list.__contains__(ifile_name)):
        self.verilog_dependency_list.append(ifile_name)
        if debug:
          print "adding " + ifile_name + " to the dependency list"
      else:
        if debug:
          print "... already in have it"
      include_fbuf = include_fbuf.partition("`include")[2]

    #remove the ports list and the module name
    fbuf = fbuf.partition(")")[2]

    #modules have lines that start with a '.'
    str_list = fbuf.splitlines()

    module_token = ""
    done = False
    while (not done):
      for i in range (0, len(str_list)):
        line = str_list[i]
        #remove white spaces
        line = line.strip()
        if (line.startswith(".") and line.endswith(",")):
          #if debug:
          #  print "found a possible module... with token: " + line
          module_token = line
          break
        #check if we reached the last line
        if (i >= len(str_list) - 1):
          done = True

      if (not done):
        #found a possible module
        #partitoin the fbuf
        #if debug:
        #  print "module token " + module_token
        module_string = fbuf.partition(module_token)[0]
        fbuf = fbuf.partition(module_token)[2]
        fbuf = fbuf.partition(";")[2]
        str_list = fbuf.splitlines()

        #get rid of everything before the possible module
        while (len(module_string.partition(";")[2]) > 0):
          module_string = module_string.partition(";")[2]

        module_string = module_string.partition("(")[0]
        module_string = module_string.strip("#")
        module_string = module_string.strip()

        m_name = module_string.partition(" ")[0]
        if debug:
          print "module name: " + m_name

        if (not deps.__contains__(m_name)):
          if debug:
            print "adding it to the deps list"
          deps.append(module_string.partition(" ")[0])


        #mlist = module_string.splitlines()
        #work backwords
        #look for the last line that has a '('
        #for i in range (0, len(mlist)):
        #  mstr = mlist[i]
        #  print "item: " + mlist[i]
        #  #mstr = mlist[len(mlist) - 1 - i]
        #  #mstr = mstr.strip()
        #  if (mstr.__contains__(" ")):
        #    if debug:
        #      print "found: " + mstr.partition(" ")[0]
        #    deps.append(mstr.partition(" ")[0])
        #    break


    return deps


